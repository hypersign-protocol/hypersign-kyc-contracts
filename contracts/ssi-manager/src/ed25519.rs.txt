use ed25519_dalek::{SigningKey, Signature, KEYPAIR_LENGTH, VerifyingKey, PUBLIC_KEY_LENGTH, Verifier};
use multibase::Base;

fn decode_multibase_public_key(multibase_str: &str) -> Result<Vec<u8>, String> {
    let decoded = multibase::decode(multibase_str).unwrap();
    let (base, data) = decoded;
    match base {
        Base::Base58Btc => {
            // println!("Decoded data (Base58btc): {:?}", data);
            //println!("Decoded data (Base58btc) vec: {:?}", data.to_vec());
        }
        _ => {
            println!("Unsupported base: {:?}", base);
        }
    }

    Ok(data)

}

fn vec_to_array<const N: usize>(input: Vec<u8>) -> Result<[u8; N], &'static str> {
    // Ensure the input Vec has the correct length for the array
    if input.len() != N {
        return Err("Input Vec length does not match the desired array length");
    }

    // Try to convert the Vec into a fixed-size array
    let mut array = [0u8; N];
    array.copy_from_slice(&input);

    Ok(array)
}

fn generate_verifying_key(public_key_str: &str) -> VerifyingKey {
    const ARRAY_LENGTH: usize = 34;
    let public_key_bytes = decode_multibase_public_key(public_key_str).unwrap();
    let t_public_key_array = vec_to_array::<ARRAY_LENGTH>(public_key_bytes.to_owned()).unwrap();
    println!("t_public_key_array.len {:?}",t_public_key_array.len());

    // extract secret key from index 2 to 32
    let public_key_start_index = 2;
    let public_key_end_index = t_public_key_array.len();
    let public_key_array: [u8; 32] = t_public_key_array[
        public_key_start_index..public_key_end_index
    ]
        .try_into()
        .expect("Failed to create new array");
    let public_key_bytes: [u8; PUBLIC_KEY_LENGTH] = public_key_array;
    println!("public_key_bytes.len {:?}",public_key_bytes.len());

    let verifying_key = ed25519_dalek::VerifyingKey::from_bytes(&public_key_bytes).unwrap();
    return verifying_key
}

pub fn verify_proof(public_key_str: &str,  m:  &str, signature_str1: &str) -> Bool{
    let hex_decode_message = hex::decode(m);
    let message: &[u8] = &hex_decode_message.unwrap();

    const SIGNATURE_BYTE_SIZE: usize = 64;
    let signature_bytes = decode_multibase_public_key(signature_str1).unwrap();
    println!("signature_bytes {:?}", signature_bytes.len()); 
    let signature_array = vec_to_array::<SIGNATURE_BYTE_SIZE>(signature_bytes.to_owned()).unwrap();        
    println!("signature_str1_len {:?}", signature_array.len());
    let signature: Signature = Signature::from_bytes(&signature_array);
    let verifying_key: ed25519_dalek::VerifyingKey = generate_verifying_key(&public_key_str);

    let res1 = verifying_key.verify(&message, &signature).is_ok();
    println!("result1 {:?}", res1);
    res1;
}